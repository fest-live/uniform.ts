import { UUIDv4 } from "fest/core";
import { initChannelHandler } from "../channel/Channels";
/**
 * Queued worker channel that buffers requests until the channel is available
 */
export class QueuedWorkerChannel {
    config;
    onChannelReady;
    underlyingChannel = null;
    isConnected = false;
    requestQueue = [];
    connectionPromise = null;
    connectionResolver = null;
    context;
    constructor(config, onChannelReady) {
        this.config = config;
        this.onChannelReady = onChannelReady;
        this.context = config.context ?? 'unknown';
    }
    /**
     * Initialize the underlying channel
     */
    async connect(underlyingChannel = null) {
        this.underlyingChannel = underlyingChannel;
    }
    /**
     * Queue a request if channel isn't ready, otherwise send immediately
     */
    async request(method, args = []) {
        if (this.isConnected && this.underlyingChannel) {
            return this.underlyingChannel.request(method, args);
        }
        // Queue the request
        return new Promise((resolve, reject) => {
            const queuedRequest = {
                id: UUIDv4(),
                method,
                args,
                resolve,
                reject,
                timestamp: Date.now()
            };
            this.requestQueue.push(queuedRequest);
            // Auto-connect if not already connecting
            if (!this.connectionPromise) {
                this.connect().catch((error) => {
                    this.rejectAllQueued(error);
                });
            }
        });
    }
    /**
     * Process all queued requests
     */
    async flushQueue() {
        if (!this.underlyingChannel)
            return;
        const queueCopy = [...this.requestQueue];
        this.requestQueue = [];
        for (const queuedRequest of queueCopy) {
            try {
                const result = await this.underlyingChannel.request(queuedRequest.method, queuedRequest.args);
                queuedRequest.resolve(result);
            }
            catch (error) {
                queuedRequest.reject(error);
            }
        }
    }
    /**
     * Reject all queued requests with an error
     */
    rejectAllQueued(error) {
        const queueCopy = [...this.requestQueue];
        this.requestQueue = [];
        for (const queuedRequest of queueCopy) {
            queuedRequest.reject(error);
        }
    }
    /**
     * Get queue status
     */
    getQueueStatus() {
        return {
            isConnected: this.isConnected,
            queuedRequests: this.requestQueue.length,
            isConnecting: !!this.connectionPromise && !this.isConnected
        };
    }
    close() {
        this.rejectAllQueued(new Error('Channel closed'));
        this.underlyingChannel?.close();
        this.underlyingChannel = null;
        this.isConnected = false;
        this.connectionPromise = null;
    }
}
/**
 * Default tab ID getter - gets current active tab
 */
export const getCurrentTabId = async () => {
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (tabs.length === 0) {
        throw new Error('No active tab found');
    }
    if (!tabs[0].id) {
        throw new Error('Active tab has no ID');
    }
    return tabs[0].id;
};
/**
 * Tab ID getter for visible tab (may be different from active)
 */
export const getVisibleTabId = async () => {
    // First try active tab
    try {
        return await getCurrentTabId();
    }
    catch {
        // Fallback to any visible tab
        const tabs = await chrome.tabs.query({ currentWindow: true });
        const visibleTab = tabs.find(tab => tab.active);
        if (!visibleTab?.id) {
            throw new Error('No visible tab found');
        }
        return visibleTab.id;
    }
};
/**
 * Simplified worker registration for common patterns
 */
export const registerWorkerAPI = (api, channelName = "worker") => {
    // This will be called in worker context to register functions
    const channelHandler = initChannelHandler(channelName ?? "worker");
    // Register functions in the uniform data store
    Object.keys(api).forEach(methodName => {
        const method = api[methodName];
        if (typeof method === 'function') {
            // Functions are automatically available through the uniform reflection system
            // The channel handler will proxy calls to these functions
        }
    });
    return channelHandler;
};
export class OptimizedWorkerChannel {
    channel = null;
    isChannelReady = false;
    pendingRequests = new Map();
    messageQueue = [];
    queuedRequests = [];
    batchTimer;
    options;
    onChannelReady;
    constructor(channel = null, options = {}, onChannelReady) {
        this.channel = channel;
        this.isChannelReady = !!channel;
        this.onChannelReady = onChannelReady;
        this.options = {
            timeout: 30000,
            retries: 3,
            compression: false,
            batching: true,
            ...options
        };
    }
    /**
     * Set the underlying channel when it becomes available
     */
    setChannel(channel) {
        this.channel = channel;
        this.isChannelReady = true;
        this.onChannelReady?.(channel);
        this.flushQueuedRequests();
    }
    /**
     * Send a request and wait for response
     */
    async request(type, payload, options) {
        // If channel is not ready, queue the request
        if (!this.isChannelReady || !this.channel) {
            return new Promise((resolve, reject) => {
                const queuedRequest = {
                    id: UUIDv4(),
                    method: type,
                    args: [payload],
                    resolve,
                    reject,
                    timestamp: Date.now()
                };
                this.queuedRequests.push(queuedRequest);
            });
        }
        const opts = { ...this.options, ...options };
        const messageId = UUIDv4();
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.pendingRequests.delete(messageId);
                reject(new Error(`Request timeout: ${type}`));
            }, opts.timeout);
            this.pendingRequests.set(messageId, { resolve, reject, timeout });
            const envelope = {
                id: messageId,
                type,
                payload,
                timestamp: Date.now()
            };
            if (opts.batching) {
                this.queueMessage(envelope);
            }
            else {
                this.sendMessage(envelope);
            }
        });
    }
    /**
     * Process queued requests when channel becomes available
     */
    async flushQueuedRequests() {
        if (!this.channel || this.queuedRequests.length === 0)
            return;
        const queueCopy = [...this.queuedRequests];
        this.queuedRequests = [];
        for (const queuedRequest of queueCopy) {
            try { // @ts-ignore
                const result = await this.request(queuedRequest.method, ...(queuedRequest?.args ?? []));
                queuedRequest.resolve(result);
            }
            catch (error) {
                queuedRequest.reject(error);
            }
        }
    }
    /**
     * Send a one-way message (fire and forget)
     */
    notify(type, payload) {
        const envelope = {
            id: UUIDv4(),
            type,
            payload,
            timestamp: Date.now()
        };
        if (this.options.batching) {
            this.queueMessage(envelope);
        }
        else {
            this.sendMessage(envelope);
        }
    }
    /**
     * Stream data with backpressure handling
     */
    async *stream(type, data) {
        for (const chunk of data) {
            const result = await this.request(`${type}:chunk`, chunk);
            yield result;
        }
    }
    /**
     * Queue message for batching
     */
    queueMessage(envelope) {
        this.messageQueue.push(envelope);
        if (!this.batchTimer) {
            this.batchTimer = setTimeout(() => {
                this.flushBatch();
            }, 16); // ~60fps
        }
    }
    /**
     * Send batched messages
     */
    flushBatch() {
        if (this.messageQueue.length === 0)
            return;
        const batchEnvelope = {
            id: UUIDv4(),
            type: "batch",
            payload: this.messageQueue,
            timestamp: Date.now()
        };
        this.sendMessage(batchEnvelope);
        this.messageQueue = [];
        this.batchTimer = undefined;
    }
    /**
     * Send single message through channel
     */
    async sendMessage(envelope) {
        try {
            const result = await this.channel?.request?.("processMessage", [envelope]);
            // Handle response if it's a reply
            if (envelope.replyTo && this.pendingRequests.has(envelope.replyTo)) {
                const { resolve, timeout } = this.pendingRequests.get(envelope.replyTo);
                clearTimeout(timeout);
                this.pendingRequests.delete(envelope.replyTo);
                resolve(result);
            }
        }
        catch (error) {
            // Handle failed message
            if (this.pendingRequests.has(envelope.id)) {
                const { reject, timeout } = this.pendingRequests.get(envelope.id);
                clearTimeout(timeout);
                this.pendingRequests.delete(envelope.id);
                reject(error);
            }
        }
    }
    /**
     * Close the channel
     */
    close() {
        if (this.batchTimer) {
            clearTimeout(this.batchTimer);
        }
        // Reject all pending requests
        for (const [id, { reject, timeout }] of this.pendingRequests) {
            clearTimeout(timeout);
            reject(new Error("Channel closed"));
        }
        //
        this.pendingRequests.clear();
        this.channel?.close?.();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVldWVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiUXVldWVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDbkMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFtRHpEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLG1CQUFtQjtJQVNoQjtJQUNBO0lBVEosaUJBQWlCLEdBQXlCLElBQUksQ0FBQztJQUMvQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0lBQ3BCLFlBQVksR0FBb0IsRUFBRSxDQUFDO0lBQ25DLGlCQUFpQixHQUF5QixJQUFJLENBQUM7SUFDL0Msa0JBQWtCLEdBQXdCLElBQUksQ0FBQztJQUMvQyxPQUFPLENBQTZEO0lBRTVFLFlBQ1ksTUFBb0IsRUFDcEIsY0FBaUQ7UUFEakQsV0FBTSxHQUFOLE1BQU0sQ0FBYztRQUNwQixtQkFBYyxHQUFkLGNBQWMsQ0FBbUM7UUFFekQsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxJQUFJLFNBQVMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsT0FBTyxDQUFDLG9CQUEwQyxJQUFJO1FBQ3hELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQWMsRUFBRSxPQUFjLEVBQUU7UUFDMUMsSUFBSSxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBQzdDLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEQsQ0FBQztRQUVELG9CQUFvQjtRQUNwQixPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ25DLE1B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LE9BQU8sQ0FBQyxDQUFDO2dCQUN0QixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3pDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNsQixDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUs7UUFDRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNsQixZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xDLENBQUM7UUFFRCw4QkFBOEI7UUFDOUIsS0FBSyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQzNELFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0QixNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLENBQUM7UUFFRCxFQUFFO1FBQ0YsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUM3QixJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUM7SUFDNUIsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVVVJRHY0IH0gZnJvbSBcImZlc3QvY29yZVwiO1xuaW1wb3J0IHsgaW5pdENoYW5uZWxIYW5kbGVyIH0gZnJvbSBcIi4uL2NoYW5uZWwvQ2hhbm5lbHNcIjtcblxuLyoqXG4gKiBUeXBlIGRlZmluaXRpb25zIGZvciBmZXN0L3VuaWZvcm1cbiAqIENlbnRyYWxpemVkIHRvIGF2b2lkIGNpcmN1bGFyIGltcG9ydCBpc3N1ZXNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtlckNoYW5uZWwge1xuICAgIHJlcXVlc3QobWV0aG9kOiBzdHJpbmcsIGFyZ3M/OiBhbnlbXSk6IFByb21pc2U8YW55PjtcbiAgICBjbG9zZSgpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtlckNvbmZpZyB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHNjcmlwdDogc3RyaW5nIHwgKCgpID0+IFdvcmtlcikgfCBXb3JrZXI7XG4gICAgb3B0aW9ucz86IFdvcmtlck9wdGlvbnM7XG4gICAgY29udGV4dD86ICdtYWluJyB8ICdzZXJ2aWNlLXdvcmtlcicgfCAnY2hyb21lLWV4dGVuc2lvbic7XG4gICAgdGFic0NoYW5uZWw/OiBib29sZWFuO1xuICAgIHRhYnNPcHRpb25zPzogeyB0YWJGaWx0ZXI/OiAodGFiOiBjaHJvbWUudGFicy5UYWIpID0+IGJvb2xlYW4gfTtcbiAgICBjdXJyZW50VGFiQ2hhbm5lbD86IGJvb2xlYW47XG4gICAgY3VycmVudFRhYk9wdGlvbnM/OiB7XG4gICAgICAgIHRhYklkR2V0dGVyPzogKCkgPT4gUHJvbWlzZTxudW1iZXI+IHwgbnVtYmVyO1xuICAgICAgICB1c2VWaXNpYmxlVGFiPzogYm9vbGVhbjtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXVlZFJlcXVlc3Qge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbWV0aG9kOiBzdHJpbmc7XG4gICAgYXJnczogYW55W107XG4gICAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gICAgcmVqZWN0OiAoZXJyb3I6IGFueSkgPT4gdm9pZDtcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlRW52ZWxvcGUge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdHlwZTogc3RyaW5nO1xuICAgIHBheWxvYWQ6IGFueTtcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICByZXBseVRvPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3RvY29sT3B0aW9ucyB7XG4gICAgdGltZW91dD86IG51bWJlcjtcbiAgICByZXRyaWVzPzogbnVtYmVyO1xuICAgIGNvbXByZXNzaW9uPzogYm9vbGVhbjtcbiAgICBiYXRjaGluZz86IGJvb2xlYW47XG59XG5cblxuLyoqXG4gKiBRdWV1ZWQgd29ya2VyIGNoYW5uZWwgdGhhdCBidWZmZXJzIHJlcXVlc3RzIHVudGlsIHRoZSBjaGFubmVsIGlzIGF2YWlsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgUXVldWVkV29ya2VyQ2hhbm5lbCBpbXBsZW1lbnRzIFdvcmtlckNoYW5uZWwge1xuICAgIHByaXZhdGUgdW5kZXJseWluZ0NoYW5uZWw6IFdvcmtlckNoYW5uZWwgfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSByZXF1ZXN0UXVldWU6IFF1ZXVlZFJlcXVlc3RbXSA9IFtdO1xuICAgIHByaXZhdGUgY29ubmVjdGlvblByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIGNvbm5lY3Rpb25SZXNvbHZlcjogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBjb250ZXh0OiAnbWFpbicgfCAnc2VydmljZS13b3JrZXInIHwgJ2Nocm9tZS1leHRlbnNpb24nIHwgJ3Vua25vd24nO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgY29uZmlnOiBXb3JrZXJDb25maWcsXG4gICAgICAgIHByaXZhdGUgb25DaGFubmVsUmVhZHk/OiAoY2hhbm5lbDogV29ya2VyQ2hhbm5lbCkgPT4gdm9pZFxuICAgICkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb25maWcuY29udGV4dCA/PyAndW5rbm93bic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgdW5kZXJseWluZyBjaGFubmVsXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCh1bmRlcmx5aW5nQ2hhbm5lbDogV29ya2VyQ2hhbm5lbCB8IG51bGwgPSBudWxsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NoYW5uZWwgPSB1bmRlcmx5aW5nQ2hhbm5lbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSBhIHJlcXVlc3QgaWYgY2hhbm5lbCBpc24ndCByZWFkeSwgb3RoZXJ3aXNlIHNlbmQgaW1tZWRpYXRlbHlcbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0KG1ldGhvZDogc3RyaW5nLCBhcmdzOiBhbnlbXSA9IFtdKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQgJiYgdGhpcy51bmRlcmx5aW5nQ2hhbm5lbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5kZXJseWluZ0NoYW5uZWwucmVxdWVzdChtZXRob2QsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVldWUgdGhlIHJlcXVlc3RcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlZFJlcXVlc3Q6IFF1ZXVlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IFVVSUR2NCgpLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUucHVzaChxdWV1ZWRSZXF1ZXN0KTtcblxuICAgICAgICAgICAgLy8gQXV0by1jb25uZWN0IGlmIG5vdCBhbHJlYWR5IGNvbm5lY3RpbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdEFsbFF1ZXVlZChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIHF1ZXVlZCByZXF1ZXN0c1xuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgZmx1c2hRdWV1ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLnVuZGVybHlpbmdDaGFubmVsKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgcXVldWVDb3B5ID0gWy4uLnRoaXMucmVxdWVzdFF1ZXVlXTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXVlZFJlcXVlc3Qgb2YgcXVldWVDb3B5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudW5kZXJseWluZ0NoYW5uZWwucmVxdWVzdChxdWV1ZWRSZXF1ZXN0Lm1ldGhvZCwgcXVldWVkUmVxdWVzdC5hcmdzKTtcbiAgICAgICAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcXVldWVkUmVxdWVzdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVqZWN0IGFsbCBxdWV1ZWQgcmVxdWVzdHMgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuICAgIHByaXZhdGUgcmVqZWN0QWxsUXVldWVkKGVycm9yOiBFcnJvcik6IHZvaWQge1xuICAgICAgICBjb25zdCBxdWV1ZUNvcHkgPSBbLi4udGhpcy5yZXF1ZXN0UXVldWVdO1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgcXVldWVkUmVxdWVzdCBvZiBxdWV1ZUNvcHkpIHtcbiAgICAgICAgICAgIHF1ZXVlZFJlcXVlc3QucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBxdWV1ZSBzdGF0dXNcbiAgICAgKi9cbiAgICBnZXRRdWV1ZVN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzQ29ubmVjdGVkOiB0aGlzLmlzQ29ubmVjdGVkLFxuICAgICAgICAgICAgcXVldWVkUmVxdWVzdHM6IHRoaXMucmVxdWVzdFF1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZzogISF0aGlzLmNvbm5lY3Rpb25Qcm9taXNlICYmICF0aGlzLmlzQ29ubmVjdGVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVqZWN0QWxsUXVldWVkKG5ldyBFcnJvcignQ2hhbm5lbCBjbG9zZWQnKSk7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NoYW5uZWw/LmNsb3NlKCk7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NoYW5uZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBudWxsO1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogRGVmYXVsdCB0YWIgSUQgZ2V0dGVyIC0gZ2V0cyBjdXJyZW50IGFjdGl2ZSB0YWJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRUYWJJZCA9IGFzeW5jICgpOiBQcm9taXNlPG51bWJlcj4gPT4ge1xuICAgIGNvbnN0IHRhYnMgPSBhd2FpdCBjaHJvbWUudGFicy5xdWVyeSh7IGFjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZSB9KTtcbiAgICBpZiAodGFicy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgdGFiIGZvdW5kJyk7XG4gICAgfVxuICAgIGlmICghdGFic1swXS5pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2ZSB0YWIgaGFzIG5vIElEJyk7XG4gICAgfVxuICAgIHJldHVybiB0YWJzWzBdLmlkO1xufTtcblxuLyoqXG4gKiBUYWIgSUQgZ2V0dGVyIGZvciB2aXNpYmxlIHRhYiAobWF5IGJlIGRpZmZlcmVudCBmcm9tIGFjdGl2ZSlcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFZpc2libGVUYWJJZCA9IGFzeW5jICgpOiBQcm9taXNlPG51bWJlcj4gPT4ge1xuICAgIC8vIEZpcnN0IHRyeSBhY3RpdmUgdGFiXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldEN1cnJlbnRUYWJJZCgpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBhbnkgdmlzaWJsZSB0YWJcbiAgICAgICAgY29uc3QgdGFicyA9IGF3YWl0IGNocm9tZS50YWJzLnF1ZXJ5KHsgY3VycmVudFdpbmRvdzogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgdmlzaWJsZVRhYiA9IHRhYnMuZmluZCh0YWIgPT4gdGFiLmFjdGl2ZSk7XG4gICAgICAgIGlmICghdmlzaWJsZVRhYj8uaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmlzaWJsZSB0YWIgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZVRhYi5pZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENocm9tZSBFeHRlbnNpb24gUnVudGltZSBNb2R1bGUgSW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3J4UnVudGltZU1vZHVsZSB7XG4gICAgLy8gQ2FwdHVyZSBzY3JlZW5zaG90ICsgQUkgcHJvY2Vzc2luZyBpbiBvbmUgY2FsbFxuICAgIGNhcHR1cmUocmVjdD86IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0sIG1vZGU/OiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG5cbiAgICAvLyBKdXN0IGNhcHR1cmUgc2NyZWVuc2hvdCwgcmV0dXJuIGltYWdlIGRhdGFcbiAgICBjYXB0dXJlU2NyZWVuc2hvdChyZWN0PzogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSk6IFByb21pc2U8YW55PjtcblxuICAgIC8vIFByb2Nlc3MgY2FwdHVyZWQgaW1hZ2UgZGF0YSB3aXRoIEFJXG4gICAgcHJvY2Vzc0ltYWdlKGltYWdlRGF0YTogc3RyaW5nIHwgQmxvYiwgbW9kZT86IHN0cmluZyk6IFByb21pc2U8YW55PjtcblxuICAgIHByb2Nlc3NUZXh0KHRleHQ6IHN0cmluZywgb3B0aW9ucz86IHsgdHlwZT86IHN0cmluZyB9KTogUHJvbWlzZTxhbnk+O1xuICAgIGRvQ29weShkYXRhOiB7IHRleHQ/OiBzdHJpbmc7IGRhdGE/OiBhbnkgfSwgb3B0aW9ucz86IHsgc2hvd1RvYXN0PzogYm9vbGVhbiB9KTogUHJvbWlzZTxhbnk+O1xuICAgIGxvYWRNYXJrZG93bihzcmM6IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICBjYXB0dXJlV2l0aFJlY3QobW9kZT86IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICBnZXRDdXJyZW50VGFiKCk6IFByb21pc2U8Y2hyb21lLnRhYnMuVGFiIHwgbnVsbD47XG4gICAgc2VuZE1lc3NhZ2UodHlwZTogc3RyaW5nLCBkYXRhPzogYW55KTogUHJvbWlzZTxhbnk+O1xuICAgIGNsb3NlKCk6IHZvaWQ7XG59XG5cbi8qKlxuICogU2ltcGxpZmllZCB3b3JrZXIgcmVnaXN0cmF0aW9uIGZvciBjb21tb24gcGF0dGVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyV29ya2VyQVBJID0gKGFwaTogUmVjb3JkPHN0cmluZywgRnVuY3Rpb24+LCBjaGFubmVsTmFtZTogc3RyaW5nID0gXCJ3b3JrZXJcIikgPT4ge1xuICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgaW4gd29ya2VyIGNvbnRleHQgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zXG4gICAgY29uc3QgY2hhbm5lbEhhbmRsZXIgPSBpbml0Q2hhbm5lbEhhbmRsZXIoY2hhbm5lbE5hbWUgPz8gXCJ3b3JrZXJcIik7XG5cbiAgICAvLyBSZWdpc3RlciBmdW5jdGlvbnMgaW4gdGhlIHVuaWZvcm0gZGF0YSBzdG9yZVxuICAgIE9iamVjdC5rZXlzKGFwaSkuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gYXBpW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gRnVuY3Rpb25zIGFyZSBhdXRvbWF0aWNhbGx5IGF2YWlsYWJsZSB0aHJvdWdoIHRoZSB1bmlmb3JtIHJlZmxlY3Rpb24gc3lzdGVtXG4gICAgICAgICAgICAvLyBUaGUgY2hhbm5lbCBoYW5kbGVyIHdpbGwgcHJveHkgY2FsbHMgdG8gdGhlc2UgZnVuY3Rpb25zXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjaGFubmVsSGFuZGxlcjtcbn07XG5cbi8qKlxuICogT3B0aW1pemVkIGNvbW11bmljYXRpb24gcHJvdG9jb2wgZm9yIGZlc3QvdW5pZm9ybVxuICogUHJvdmlkZXMgZWZmaWNpZW50IG1lc3NhZ2UgcGFzc2luZyBhbmQgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBQcm90b2NvbE9wdGlvbnMge1xuICAgIHRpbWVvdXQ/OiBudW1iZXI7XG4gICAgcmV0cmllcz86IG51bWJlcjtcbiAgICBjb21wcmVzc2lvbj86IGJvb2xlYW47XG4gICAgYmF0Y2hpbmc/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgT3B0aW1pemVkV29ya2VyQ2hhbm5lbCB7XG4gICAgcHJpdmF0ZSBjaGFubmVsOiBXb3JrZXJDaGFubmVsIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBpc0NoYW5uZWxSZWFkeSA9IGZhbHNlO1xuICAgIHByaXZhdGUgcGVuZGluZ1JlcXVlc3RzID0gbmV3IE1hcDxzdHJpbmcsIHtcbiAgICAgICAgcmVzb2x2ZTogRnVuY3Rpb247XG4gICAgICAgIHJlamVjdDogRnVuY3Rpb247XG4gICAgICAgIHRpbWVvdXQ6IG51bWJlcjtcbiAgICB9PigpO1xuICAgIHByaXZhdGUgbWVzc2FnZVF1ZXVlOiBNZXNzYWdlRW52ZWxvcGVbXSA9IFtdO1xuICAgIHByaXZhdGUgcXVldWVkUmVxdWVzdHM6IFF1ZXVlZFJlcXVlc3RbXSA9IFtdO1xuICAgIHByaXZhdGUgYmF0Y2hUaW1lcj86IG51bWJlcjtcbiAgICBwcml2YXRlIG9wdGlvbnM6IFJlcXVpcmVkPFByb3RvY29sT3B0aW9ucz47XG4gICAgcHJpdmF0ZSBvbkNoYW5uZWxSZWFkeT86IChjaGFubmVsOiBXb3JrZXJDaGFubmVsKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGNoYW5uZWw6IFdvcmtlckNoYW5uZWwgfCBudWxsID0gbnVsbCxcbiAgICAgICAgb3B0aW9uczogUHJvdG9jb2xPcHRpb25zID0ge30sXG4gICAgICAgIG9uQ2hhbm5lbFJlYWR5PzogKGNoYW5uZWw6IFdvcmtlckNoYW5uZWwpID0+IHZvaWRcbiAgICApIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5pc0NoYW5uZWxSZWFkeSA9ICEhY2hhbm5lbDtcbiAgICAgICAgdGhpcy5vbkNoYW5uZWxSZWFkeSA9IG9uQ2hhbm5lbFJlYWR5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0aW1lb3V0OiAzMDAwMCxcbiAgICAgICAgICAgIHJldHJpZXM6IDMsXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogZmFsc2UsXG4gICAgICAgICAgICBiYXRjaGluZzogdHJ1ZSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHVuZGVybHlpbmcgY2hhbm5lbCB3aGVuIGl0IGJlY29tZXMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgc2V0Q2hhbm5lbChjaGFubmVsOiBXb3JrZXJDaGFubmVsKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuaXNDaGFubmVsUmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uQ2hhbm5lbFJlYWR5Py4oY2hhbm5lbCk7XG4gICAgICAgIHRoaXMuZmx1c2hRdWV1ZWRSZXF1ZXN0cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSByZXF1ZXN0IGFuZCB3YWl0IGZvciByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3QodHlwZTogc3RyaW5nLCBwYXlsb2FkOiBhbnksIG9wdGlvbnM/OiBQYXJ0aWFsPFByb3RvY29sT3B0aW9ucz4pOiBQcm9taXNlPGFueT4ge1xuICAgICAgICAvLyBJZiBjaGFubmVsIGlzIG5vdCByZWFkeSwgcXVldWUgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2hhbm5lbFJlYWR5IHx8ICF0aGlzLmNoYW5uZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVkUmVxdWVzdDogUXVldWVkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFVVSUR2NCgpLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtwYXlsb2FkXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVkUmVxdWVzdHMucHVzaChxdWV1ZWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3B0cyA9IHsgLi4udGhpcy5vcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IFVVSUR2NCgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUmVxdWVzdCB0aW1lb3V0OiAke3R5cGV9YCkpO1xuICAgICAgICAgICAgfSwgb3B0cy50aW1lb3V0KTtcblxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuc2V0KG1lc3NhZ2VJZCwgeyByZXNvbHZlLCByZWplY3QsIHRpbWVvdXQgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGVudmVsb3BlOiBNZXNzYWdlRW52ZWxvcGUgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAob3B0cy5iYXRjaGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVNZXNzYWdlKGVudmVsb3BlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShlbnZlbG9wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgcXVldWVkIHJlcXVlc3RzIHdoZW4gY2hhbm5lbCBiZWNvbWVzIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgZmx1c2hRdWV1ZWRSZXF1ZXN0cygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYW5uZWwgfHwgdGhpcy5xdWV1ZWRSZXF1ZXN0cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBjb25zdCBxdWV1ZUNvcHkgPSBbLi4udGhpcy5xdWV1ZWRSZXF1ZXN0c107XG4gICAgICAgIHRoaXMucXVldWVkUmVxdWVzdHMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXVlZFJlcXVlc3Qgb2YgcXVldWVDb3B5KSB7XG4gICAgICAgICAgICB0cnkgeyAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHF1ZXVlZFJlcXVlc3QubWV0aG9kLCAuLi4oKHF1ZXVlZFJlcXVlc3Q/LmFyZ3MgPz8gW10pIGFzIGFueSkpO1xuICAgICAgICAgICAgICAgIHF1ZXVlZFJlcXVlc3QucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgb25lLXdheSBtZXNzYWdlIChmaXJlIGFuZCBmb3JnZXQpXG4gICAgICovXG4gICAgbm90aWZ5KHR5cGU6IHN0cmluZywgcGF5bG9hZDogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlOiBNZXNzYWdlRW52ZWxvcGUgPSB7XG4gICAgICAgICAgICBpZDogVVVJRHY0KCksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmF0Y2hpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVNZXNzYWdlKGVudmVsb3BlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoZW52ZWxvcGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RyZWFtIGRhdGEgd2l0aCBiYWNrcHJlc3N1cmUgaGFuZGxpbmdcbiAgICAgKi9cbiAgICBhc3luYyAqc3RyZWFtKHR5cGU6IHN0cmluZywgZGF0YTogYW55W10pOiBBc3luY0dlbmVyYXRvcjxhbnk+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYCR7dHlwZX06Y2h1bmtgLCBjaHVuayk7XG4gICAgICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSBtZXNzYWdlIGZvciBiYXRjaGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgcXVldWVNZXNzYWdlKGVudmVsb3BlOiBNZXNzYWdlRW52ZWxvcGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUucHVzaChlbnZlbG9wZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCYXRjaCgpO1xuICAgICAgICAgICAgfSwgMTYpOyAvLyB+NjBmcHNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYmF0Y2hlZCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHByaXZhdGUgZmx1c2hCYXRjaCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZVF1ZXVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGJhdGNoRW52ZWxvcGU6IE1lc3NhZ2VFbnZlbG9wZSA9IHtcbiAgICAgICAgICAgIGlkOiBVVUlEdjQoKSxcbiAgICAgICAgICAgIHR5cGU6IFwiYmF0Y2hcIixcbiAgICAgICAgICAgIHBheWxvYWQ6IHRoaXMubWVzc2FnZVF1ZXVlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShiYXRjaEVudmVsb3BlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5iYXRjaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgc2luZ2xlIG1lc3NhZ2UgdGhyb3VnaCBjaGFubmVsXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBzZW5kTWVzc2FnZShlbnZlbG9wZTogTWVzc2FnZUVudmVsb3BlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNoYW5uZWw/LnJlcXVlc3Q/LihcInByb2Nlc3NNZXNzYWdlXCIsIFtlbnZlbG9wZV0pO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgcmVzcG9uc2UgaWYgaXQncyBhIHJlcGx5XG4gICAgICAgICAgICBpZiAoZW52ZWxvcGUucmVwbHlUbyAmJiB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5oYXMoZW52ZWxvcGUucmVwbHlUbykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlc29sdmUsIHRpbWVvdXQgfSA9IHRoaXMucGVuZGluZ1JlcXVlc3RzLmdldChlbnZlbG9wZS5yZXBseVRvKSE7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShlbnZlbG9wZS5yZXBseVRvKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZmFpbGVkIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdSZXF1ZXN0cy5oYXMoZW52ZWxvcGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZWplY3QsIHRpbWVvdXQgfSA9IHRoaXMucGVuZGluZ1JlcXVlc3RzLmdldChlbnZlbG9wZS5pZCkhO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5kZWxldGUoZW52ZWxvcGUuaWQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGNsb3NlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5iYXRjaFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5iYXRjaFRpbWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlamVjdCBhbGwgcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICBmb3IgKGNvbnN0IFtpZCwgeyByZWplY3QsIHRpbWVvdXQgfV0gb2YgdGhpcy5wZW5kaW5nUmVxdWVzdHMpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDaGFubmVsIGNsb3NlZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNoYW5uZWw/LmNsb3NlPy4oKTtcbiAgICB9XG59XG4iXX0=